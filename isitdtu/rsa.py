n = 603040899191765499692105412408128039799635285914243838639458755491385487537245112353139626673905393100145421529413079339538777058510964724244525164265239307111938912323072543529589488452173312928447289267651249034509309453696972053651162310797873759227949341560295688041964008368596191262760564685226946006231

c = 153348390614662968396805701018941225929976855876673665545678808357493865670852637784454103632206407687489178974011663144922612614936251484669376715328818177626125051048699207156003563901638883835345344061093282392322541967439067639713967480376436913225761668591305793224841429397848597912616509823391639856132

c = 90662092060215737859537038182975518200984426328685493362516131638590502170696514759186935212473130210953915866241167688589900513718205679815549392853252479747411361194792540878830307545949103996222296606171629516836550796664461718085241953505025932678082828664887184119390757358707277774518067091646489454602

220288002741191191388858841374624972922296757760517962352989311616271709980634599527299954629549158005797873118642654562401483529607271504904821857020136693466112133607216039755898147079072127133927634820870168277720893019140003503577042804648535351263161177514206633681895974593959927590898612679828301018423

# Computed factors of n
factors = [49554910022538628938758668579203617812724567561799799549233532475009657916989, 495549100225386289387586685792036178127245675617997995492335324750096579170109,
        24556891073418994576751524607635760117996811894972202516187698043229292302109114380884247668494990605537878648233446996676371523211326680052450374168750431]

assert (n == factors[0] * factors[1] * factors[2])

# Computing Euler's totient function
phi = 1
for factor in factors:
    phi *= (factor - 1)

# public key should be the most common
e = 65537

def get_string(item):
    s = str(hex(item))[2:]
    i = 0
    n = ""
    sol = ""
    for c in s:
        n += c
        i += 1
        if i == 2:
            i = 0
            n = long(n, 16)
            sol += chr(n)
            n = ""
    return sol

def logpw(n, p, mod):
    result = 1L
    while p:
        if p & 1:
            result = (result * n) % mod
        n = (n * n) % mod
        p >>= 1
    return result

def euclid_extended(a, b):
    if not b: return (1, 0)

    result = euclid_extended(b, a % b)
    return (result[1], result[0] - (a / b) * result[1])

def modular_inverse(n, mod):
    inv = euclid_extended(n, mod)[0]
    while inv < 0:
        inv += mod
    return inv

d = modular_inverse(e, phi) # private key

m = logpw(c, d, n) # original message

print get_string(m)
